BEGIN{
    //
    // This code is so horrible because in this farce of a language all variables 
    // seem to have a global scope, because of this, there is no stack, so no 
    // useful recursion of any kind
    //

    //
    // The number of nodes with no ancestors
    // and an index for stepping through them
    //
    int head_count = 0;
    int head_index = 0;
    
    //
    // This returns the next seed color for a starting node
    //
    string SeedColor()
    {
        head_index += 1;
        string seed_color;
        seed_color = (string)((double)head_index / (double)head_count) + " 0.7 1.0";
        return seed_color;
    }

    //
    // All the nodes that we want to distribute colors for when we run SpaceColors
    //
    int nodes_to_space_size;
    node_t nodes_to_space[int];

    //
    // The color ordering stores all nodes's hue value for sorting
    //
    int color_ordering_size;
    node_t color_ordering[double];

    //
    // color_duplicates[n] points to a node which should end up with the same color as n
    //
    int color_duplicates_size;
    node_t color_duplicates[node_t];

    void SpaceColors()
    {
        //
        // iterate over all the nodes to sort by hue
        //
        unset( color_ordering );
        color_ordering_size = 0;

        unset( color_duplicates );
        color_duplicates_size = 0;

        int SpaceColors_i;
        for( nodes_to_space[SpaceColors_i] )
        {
            node_t SpaceColors_o;
            SpaceColors_o = nodes_to_space[SpaceColors_i];

            //
            // Get the hue
            //
            double SpaceColors_hue;
            sscanf( SpaceColors_o.color, "%f", &SpaceColors_hue );
            if( color_ordering[SpaceColors_hue] != NULL )
            {
                color_duplicates[SpaceColors_o] = color_ordering[SpaceColors_hue];
                color_duplicates_size += 1;
            }
            else
            {
                color_ordering[SpaceColors_hue] = SpaceColors_o;
                color_ordering_size += 1;
            }

        }

        //
        // iterate through the nodes in order and assign them colors
        //
        head_count = color_ordering_size;
        head_index = 0;

        for( color_ordering[SpaceColors_hue] )
        {
            node_t SpaceColors_n;
            SpaceColors_n = color_ordering[SpaceColors_hue];
            SpaceColors_n.color = SeedColor();
        }

        //
        // iterate over all the duplicates
        //
        node_t SpaceColors_m;
        for( color_duplicates[SpaceColors_m] )
        {
            SpaceColors_m.color = color_duplicates[SpaceColors_m].color;
        }
    }

    //
    // An array of colors to populate and average from parents
    //
    string colors[int];
    double weights[int];
    int colors_size;

    //
    // This steps through all the parents of the node and fills colors with their colors
    //
    void PopulateColors( node_t PopulateColors_n )
    {


        edge_t PopulateColors_e;
        PopulateColors_e = fstin(PopulateColors_n);
        colors_size = 0;
        unset( colors );
        unset( weights );
        while( PopulateColors_e != NULL )
        {
            node_t PopulateColors_m;
            PopulateColors_m = PopulateColors_e.tail;

            //if( PopulateColors_n.name == "sally" )
                //printf( "Adding %s\n", PopulateColors_m.color );

            colors[colors_size] = PopulateColors_m.color;
            weights[colors_size] = 1.0 / (double)PopulateColors_m.outdegree;
            PopulateColors_e = nxtin(PopulateColors_e);
            colors_size += 1;
        }
    }

    //
    // This averages the hue of all the colors in colors
    //
    string AverageColors()
    {
        if( colors_size == 1.0 )
            return colors[0];

        double AverageColors_x = 0;
        double AverageColors_y = 0;
        double AverageColors_theta;

        int AverageColors_i;
        for( colors[AverageColors_i] )
        {
            sscanf( colors[AverageColors_i], "%f", &AverageColors_theta );
            AverageColors_theta -= 0.5;
            AverageColors_theta *= 2 * atan2(0,-1);
            AverageColors_x += cos(AverageColors_theta) * weights[AverageColors_i];
            AverageColors_y += sin(AverageColors_theta) * weights[AverageColors_i];
        }


        AverageColors_theta = atan2(AverageColors_y, AverageColors_x);
        AverageColors_theta /= 2 * atan2(0,-1);
        AverageColors_theta += 0.5;
        /*AverageColors_theta += (rand()-0.5)/6;
        if( AverageColors_theta > 1.0 )
            AverageColors_theta -= 1.0;
        else if (AverageColors_theta < 0.0 )
            AverageColors_theta += 1.0;
            */
        
        return sprintf( "%f 0.7 1.0", AverageColors_theta );
    }

    //
    // This array holds the next edge to explore from a particular node or NULL
    //
    edge_t node_next_edge[node_t];

    //
    // This will return the next unexplored edge for a particular node
    //
    edge_t GetEdge( node_t GetEdge_n )
    {
        if( node_next_edge[GetEdge_n] == NULL )
            return NULL;
        edge_t GetEdge_temp;
        GetEdge_temp = node_next_edge[GetEdge_n];
        node_next_edge[GetEdge_n] = nxtin( GetEdge_temp );
        return GetEdge_temp;
    }

    //
    // This will reset the explored edges for a particular node
    //
    void ResetEdge( node_t ResetEdge_n )
    {
        //
        // If this isn't a head node, initialize the next parent node array
        //
        if( ResetEdge_n.indegree != 0.0 )
            node_next_edge[ResetEdge_n] = fstin(ResetEdge_n);
    }

    //
    // For some unknown reason I can't declare this in a function scope
    //
    node_t ancestors[int];

    //
    // The main useful function, this sets the color for a node and while it's
    // at it sets the color for all the ancestors
    //
    void SetColor( node_t first )
    {
        //
        // If we already have a color skip this node
        //
        if( first.color != "" )
            return;

        edge_t e;
        node_t n;

        //
        // Ancestors contains all the nodes above this one
        //
        int position = -1;
        int num_ancestors = 0;
        unset( ancestors );
        ancestors[-1] = first;
        
        while( num_ancestors > position )
        {
            n = ancestors[position];

            e = GetEdge( n );
            while( e != NULL )
            {
                node_t t;
                t = e.tail;
                if( t.color == "" )
                {
                    ancestors[num_ancestors] = t;
                    num_ancestors += 1;
                }
                e = GetEdge( n );
            }
            ResetEdge( n );
            
            position += 1;
        }

        //
        // Traverse ancestors backwards, starting from the top of the graph
        //
        int i;
        forr( ancestors[i] )
        {

            //
            // It's possible (almost certain given the amount of incest) that
            // we've seen this ancestor before through some other path, if we
            // have then just skip them
            //
            if( ancestors[i].color != "" )
                continue;

            //
            // Grab the colors of the parents and average them
            //
            PopulateColors( ancestors[i] );
            ancestors[i].color = AverageColors();

            nodes_to_space[nodes_to_space_size] = ancestors[i];
            nodes_to_space_size += 1;
            SpaceColors();
        }
    }
}

BEG_G {
    color_duplicates_size = 0;
    color_ordering_size = 0;
    nodes_to_space_size = 0;
    head_index = 0;
}
N {
    if( indegree == 0.0 )
        head_count += 1;
}
N {
    ResetEdge( $ );
}

BEG_G { 
}
N {
    //
    // Initialize all the root colors
    //
    if( indegree == 0.0 )
    {
       color = SeedColor();
       nodes_to_space[nodes_to_space_size] = $;
       nodes_to_space_size += 1;
    }
    else
        color = "";
}

BEG_G {
}
N [name == "joe_hermaszewski"] {
    //
    // Winner's red
    //
    color = colorx( "#ff1337", "HSV" );
}

BEG_G { 
}
N {
    SetColor( $ );
}

//BEG_G {
//}
//N {
    //nodes_to_space[nodes_to_space_size] = $;
    //nodes_to_space_size += 1;
//}

//BEG_G {
    //SpaceColors();
//}

BEG_G{
}
E {
    color = tail.color;
}

N [name == "andrea" || name == "sally"] {
    //printf( "end: %s\n", color );
}

END_G { 
    $O = $G; 
}
